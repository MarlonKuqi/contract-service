# üîß Fix: G√©n√©ration d'UUID - Infrastructure vs Domain

## Probl√®me identifi√©

Apr√®s la migration vers l'immutabilit√©, **tous les tests d'int√©gration √©chouaient avec HTTP 500** lors de la cr√©ation de clients.

### Erreurs
```
Expected status code <201> but was <500>
```

### Cause root

**Conflit de g√©n√©ration d'UUID** entre le domaine et l'infrastructure :

1. **Domain** : `Person.create()` g√©n√©rait un UUID avec `UUID.randomUUID()`
2. **Infrastructure** : `ClientJpaEntity` avait `@GeneratedValue(strategy = GenerationType.UUID)`

**R√©sultat** : JPA recevait une entit√© avec un ID d√©j√† pr√©sent et essayait de faire un **MERGE** au lieu d'un **PERSIST**, ce qui √©chouait car l'entit√© n'existait pas en base.

## D√©cision architecturale

### Option 1 : Domain contr√¥le l'UUID (DDD pur) ‚ùå
- Supprimer `@GeneratedValue` 
- Laisser le domain g√©n√©rer l'UUID
- **Rejet√©** : L'infrastructure doit g√©rer la persistance

### Option 2 : Infrastructure contr√¥le l'UUID (Pragmatique) ‚úÖ
- Garder `@GeneratedValue` dans JPA
- Le domain cr√©e des objets avec `id=null`
- JPA g√©n√®re l'UUID lors du persist
- Le repository retourne l'objet avec l'UUID g√©n√©r√©

**Choix retenu** : Option 2 - S√©paration claire des responsabilit√©s

## Solution appliqu√©e

### 1. Person.create() - ID null

**Avant** :
```java
public static Person create(...) {
    return new Person(UUID.randomUUID(), name, email, phone, birthDate);
}
```

**Apr√®s** :
```java
// Factory method for creation - ID will be generated by infrastructure layer (JPA)
public static Person create(...) {
    return new Person(null, name, email, phone, birthDate);
}
```

### 2. Company.create() - ID null

**M√™me changement** :
```java
public static Company create(...) {
    return new Company(null, name, email, phone, companyIdentifier);
}
```

### 3. Infrastructure - G√©n√©ration JPA

**ClientJpaEntity** (inchang√©) :
```java
@Id
@GeneratedValue(strategy = GenerationType.UUID)
@Column(name = "id", nullable = false, updatable = false)
private UUID id;
```

### 4. Repository - Retourne l'entit√© persist√©e

**JpaClientRepository** (d√©j√† correct) :
```java
@Override
public Client save(final Client c) {
    var entity = assembler.toJpaEntity(c);      // id = null pour cr√©ation
    var savedEntity = jpa.save(entity);          // JPA g√©n√®re l'UUID
    return assembler.toDomain(savedEntity);      // Retourne avec ID g√©n√©r√©
}
```

### 5. Assembler - Gestion conditionnelle

**ClientAssembler** (d√©j√† correct) :
```java
public ClientJpaEntity toJpaEntity(Client domain) {
    ClientJpaEntity entity = switch (domain) {
        case Person person -> PersonJpaEntity.create(...);
        case Company company -> CompanyJpaEntity.create(...);
    };
    
    // Set ID UNIQUEMENT pour les modifications
    if (domain.getId() != null) {
        entity.setId(domain.getId());
    }
    
    return entity;
}
```

## Flow de cr√©ation

### Avant (Probl√®me)
```
1. Domain: Person.create() ‚Üí id = UUID.randomUUID() 
2. Service: save(person)
3. Assembler: toJpaEntity(person) ‚Üí entity.setId(person.getId())
4. JPA: entity.getId() != null ‚Üí MERGE ‚ùå
5. Error: EntityNotFoundException (l'entit√© n'existe pas)
```

### Apr√®s (Solution)
```
1. Domain: Person.create() ‚Üí id = null ‚úÖ
2. Service: save(person)
3. Assembler: toJpaEntity(person) ‚Üí entity.getId() == null
4. JPA: entity.getId() == null ‚Üí PERSIST ‚úÖ
5. JPA: G√©n√®re UUID avec @GeneratedValue
6. Repository: Retourne person avec ID g√©n√©r√© ‚úÖ
```

## Flow de modification

```
1. Repository: findById() ‚Üí person avec id != null
2. Domain: person.withName(newName) ‚Üí nouvelle instance avec m√™me ID
3. Service: save(updatedPerson)
4. Assembler: toJpaEntity(updatedPerson) ‚Üí entity.setId(updatedPerson.getId())
5. JPA: entity.getId() != null ‚Üí MERGE ‚úÖ
6. Repository: Retourne person modifi√©
```

## Impact sur les tests

### Tests unitaires - Aucun impact
Les tests unitaires utilisent le **builder** qui permet de sp√©cifier l'ID :
```java
Person person = Person.builder()
    .id(UUID.randomUUID())  // Contr√¥le total dans les tests
    .name(...)
    .build();
```

### Tests d'int√©gration - Fix automatique
Les tests d'int√©gration appellent l'API REST compl√®te :
```java
// 1. POST /clients ‚Üí Cr√©ation
given()
    .body(createPayload)
    .post("/clients")
    .then()
    .statusCode(201)  // ‚úÖ Fonctionne maintenant
    .body("id", notNullValue());  // ID g√©n√©r√© par JPA
```

## Principes architecturaux respect√©s

### ‚úÖ Separation of Concerns
- **Domain** : Logique m√©tier, validation
- **Infrastructure** : Persistance, g√©n√©ration d'ID technique

### ‚úÖ Immutabilit√© pr√©serv√©e
- Les objets du domaine restent immutables
- Cr√©ation de nouvelles instances pour les modifications

### ‚úÖ Layered Architecture
- Le domaine ne d√©pend pas de JPA
- L'infrastructure g√®re les d√©tails techniques

### ‚úÖ DDD Tactical Patterns
- **Factory methods** : `create()`, `reconstitute()`
- **Repository** : Abstraction de la persistance
- **Assembler** : Mapping Domain ‚Üî Infrastructure

## Consid√©rations

### UUID : Identit√© m√©tier vs Identit√© technique

**Identit√© technique** (notre choix) :
- UUID g√©n√©r√© par la base de donn√©es
- Pas de signification m√©tier
- Optimis√© pour la performance BDD

**Identit√© m√©tier** (alternative DDD pure) :
- UUID g√©n√©r√© par le domain
- Contr√¥le total du domain sur son identit√©
- N√©cessite de configurer JPA pour ne pas g√©n√©rer

### Notre contexte
Pour ce projet, l'UUID est une **identit√© technique** :
- Pas de r√®gle m√©tier sur sa g√©n√©ration
- Pas besoin de conna√Ætre l'ID avant la persistance
- Performance et simplicit√© privil√©gi√©es

## V√©rification

### Avant le fix
```bash
mvn clean test -Dtest=CompanyLifecycleIT
# [ERROR] 8 tests failed with HTTP 500
```

### Apr√®s le fix
```bash
mvn clean test -Dtest=CompanyLifecycleIT
# [INFO] All tests pass ‚úÖ
```

## Conclusion

**D√©cision** : L'infrastructure (JPA) contr√¥le la g√©n√©ration des UUID.

**Avantages** :
- ‚úÖ S√©paration claire des responsabilit√©s
- ‚úÖ Simplicit√© de l'impl√©mentation
- ‚úÖ Performance optimale de JPA
- ‚úÖ Pas de couplage du domain √† `java.util.UUID`

**Trade-off accept√©** :
- ‚ö†Ô∏è L'objet domain cr√©√© n'a pas d'ID imm√©diatement
- ‚ö†Ô∏è L'ID est disponible APR√àS la sauvegarde
- ‚úÖ Acceptable car l'ID n'a pas de signification m√©tier

**Date** : 2025-01-16
**Statut** : ‚úÖ R√âSOLU

